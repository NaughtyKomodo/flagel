<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Flagella 3D Viewer + Bubble Background</title>

  <!-- Import map ke CDN -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
      "three/examples/jsm/controls/OrbitControls": "https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js",
      "three/examples/jsm/loaders/GLTFLoader": "https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js"
    }
  }
  </script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";

    // Scene
    const scene = new THREE.Scene();

    // ðŸŽ¨ Background gradient (skybox shader)
    const vertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;
    const fragmentShader = `
      varying vec2 vUv;
      void main() {
        vec3 topColor = vec3(0.0, 0.1, 0.3);   // biru tua atas
        vec3 bottomColor = vec3(0.0, 0.4, 0.7); // biru terang bawah
        gl_FragColor = vec4(mix(bottomColor, topColor, vUv.y), 1.0);
      }
    `;
    const skyGeo = new THREE.SphereGeometry(100, 32, 32);
    const skyMat = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      side: THREE.BackSide
    });
    const sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);

    // Camera
    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 3, 12);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 0, 0);
    controls.update();

    // Lights
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.2));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(3, 10, 10);
    scene.add(dir);

    // Clock
    const clock = new THREE.Clock();
    const mixers = [];

    // Load GLB
    const loader = new GLTFLoader();
    let flagella;
    loader.load(
      "./final.glb",
      (gltf) => {
        flagella = gltf.scene;
        scene.add(flagella);

        flagella.position.set(0, 0, 0);
        flagella.scale.set(0.5, 0.5, 0.5);

        if (gltf.animations && gltf.animations.length > 0) {
          const mixer = new THREE.AnimationMixer(flagella);
          gltf.animations.forEach((clip) => {
            mixer.clipAction(clip).play();
          });
          mixers.push(mixer);
        }
      },
      undefined,
      (error) => {
        console.error("Error loading GLB:", error);
      }
    );

    // Bubble background (besar 2x)
    const bubbleGeometry = new THREE.SphereGeometry(0.2, 16, 16);
    const bubbleMaterial = new THREE.MeshPhongMaterial({
      color: 0x44ccff,
      transparent: true,
      opacity: 0.6,
      shininess: 80,
    });

    const bubbles = [];
    for (let i = 0; i < 200; i++) {
      const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
      bubble.position.set(
        (Math.random() - 0.5) * 40,
        Math.random() * 20 - 10,
        (Math.random() - 0.5) * 40
      );
      scene.add(bubble);
      bubbles.push(bubble);
    }

    // Render loop
    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      mixers.forEach((m) => m.update(delta));

      // Flagella floating
      if (flagella) {
        flagella.position.y = Math.sin(clock.elapsedTime * 2) * 0.3;
      }

      // Bubble floating
      bubbles.forEach((bubble) => {
        bubble.position.y += 0.01;
        if (bubble.position.y > 15) {
          bubble.position.y = -10;
        }
      });

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // Resize
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
